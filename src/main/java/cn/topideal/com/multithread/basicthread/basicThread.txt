//Java多线程基础
    线程的六种状态
        NEW             初始状态，线程被构建，但是还没有调用 start 方法
        RUNNABLE        运行状态，JAVA 线程把操作系统中的就绪 和运行两种状态统一称为“运行中”
        BLOCKED         阻塞状态，线程因进入同步方法获取锁对象失败而进入阻塞状态
        WAITING         等待状态，因为某种原因放弃了 CPU 使用权，如调用这些方法Object.wait、Thread.join、LockSupport.parkNanos、LockSupport.parkUntil
        TIMED_WAITING   超时等待状态，超时以后自动返回，如调用这些方法Thread.sleep、Object.wait、Thread.join、LockSupport.parkNanos、LockSupport.parkUntil等设置了超时时间
        TERMINATED      终止状态，表示当前线程执行完毕

    线程的生命周期
    新建状态(New)：新创建了一个线程对象，调用start方法前。
    就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。
    运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码。
    阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。
    阻塞的情况分三种：
        等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，
        同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。
        其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
    死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

    线程的创建方式
        继承Thread类
        实现Runnable接口
        实现Callable接口
        使用线程池


    线程中断
    线程间的一种通信机制，当其他线程通过调用当前线程的interrupt方法，将当前线程的中断状态设置为false，即向当前线程发起了一个中断请求，（尽管JavaAPI提供了诸如stop、suspend等方法强制终止线程
    但是，通过这一方式将会强迫线程终止执行，从而导致数据的一致性问题等），线程会不断的轮询这一中断标识状态，但是否中断取决于应用程序本身，调用interrupt方法仅仅只是将当前线程的中断标识设置为true，
    表示当前线程收到过中断请求，但是否响应这一中断取决于线程本身，这就给应用程序提供了一个很好的退出线程运行的机制。再次强调，调用interrupt方法仅仅只是标记当前线程的中断状态为true而已，线程并不
    会因此中断，只有应用程序显示的响应这一中断状态，并根据中断状态退出运行，线程才会退出，本质上是通过一个中间状态让线程结束运行。

    中断操作对线程各个运行状态的影响

    NEW和TERMINATED
    线程的new状态表示还未调用start方法，还未真正启动。线程的terminated状态表示线程已经运行终止。这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，所以并不会设置线程的中断标识位，什么
    事也不会发生。即对于处于new和terminated状态的线程对于中断是屏蔽的，也就是说中断操作对这两种状态下的线程是无效的。

    RUNNABLE
    如果线程处于运行状态，那么该线程的状态就是RUNNABLE，但是不一定所有处于RUNNABLE状态的线程都能获得CPU运行，在某个时间段，只能由一个线程占用CPU，那么其余的线程虽然状态是RUNNABLE，但是都没有
    处于运行状态。而我们处于RUNNABLE状态的线程在遭遇中断操作的时候只会设置该线程的中断标志位，并不会让线程实际中断，想要发现本线程已经被要求中断了则需要用程序自己去判断。这里其实Java将这种权力交
    给了我们的程序，Java给我们提供了一个中断标志位，我们的程序可以通过if判断中断标志位是否被设置来中断我们的程序而不是系统强制的中断。

    BLOCKED
    当线程处于BLOCKED状态说明该线程由于竞争某个对象的锁失败而被挂在了该对象的阻塞队列上了。那么此时发起中断操作不会对该线程产生任何影响，依然只是设置中断标志位。

    WAITING/TIMED_WAITING
    这两种状态本质上是同一种状态，只不过TIMED_WAITING在等待一段时间后会自动释放自己，而WAITING则是无限期等待，需要其他线程调用notify方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条
    件而被挂起在某个对象的等待队列上。当这些线程遇到中断操作的时候，会抛出一个InterruptedException异常，并清空中断标志位。

    interrupt：当其他线程通过调用当前线程的interrupt方法，表示向当前线程打个招呼，告诉他可以中断线程的执行了，至于什么时候中断，取决于当前线程自己。
    线程通过检查自身是否被中断来进行响应，可以通过isInterrupted()来判断是否被中断。
    volatile关键字

    //这个属于Thread类的方法，默认是会清除线程状态
    public static boolean interrupted() {
            return currentThread().isInterrupted(true);
    }

    //这个属于对象的方法，默认是不会清除线程状态
    public boolean isInterrupted() {
            return isInterrupted(false);
    }

    中断状态复位
    当前线程收到来自其他线程的中断请求时，会将当前线程的中断标识设置为true，即当前线程收到中断请求，如果当前线程没有响应这一中断操作，那么该中断标识位将一直是true，从线程安全行角度考虑，这种操作是
    不安全的，需要我们显示的对其进行复位操作，但在WAITING/TIMED_WAITING状态下对线程进行中断操作，线程会抛出InterruptedException异常，并复位中断标志。

    线程中断的使用场景
    可以通过设置interrupt()的中断标识，在程序中判断该标识是否中断，可以进行响应的程序逻辑处理，以达到程序安全的退出运行
    volatile关键字
    在WAITING/TIMED_WAITING状态下设置线程中断，并在程序中捕获InterruptedException异常，进行响应的逻辑处理，以达到程序安全的退出运行，但不推荐

    interruptException
    线程中断异常，在线程处于WAITING/TIME_WAITING状态调用线程的interrupt()方法时抛出该异常，这个异常的抛出并不代表这线程就此结束，而是表示当前处于线程阻塞中的线程收到过中断请求，线程被迫提前退
    出正在执行的逻辑，至于后续的逻辑如何处理，则需要以来程序本身的逻辑，要么自己处理逻辑异常，要们向上抛出异常等等
    其实处于阻塞状态下的线程中断并非是线程本身抛出的异常，而是获取当前锁的对象的wait或者sleep等方法抛出的异常，也就是对象内部会不断去检查此对象上的中断状态，如果发现哪个线程将此状态设置为已中断，则会
    抛出此异常，意思就是中断线程等待、睡眠等，也即等同于唤醒线程。从这也就很好的解释了线程中断异常并不是线程结束运行，而是线程通过异常形式来响应中断请求，退出阻塞状态，并以异常的形式来反馈中断请求，这种
    异常并不是我们平常理解的程序异常，而是一种通信机制。

    自己的理解
    在阻塞状态下线程中断，线程会设置中断状态，但监视器对象检测到interrupt中断后会抛出InterruptedException并复位中断状态，而其他状态下仅仅只是做了标记中断状态，并没有如此复杂的处理逻辑，其实原因很
    简单，因为在其他状态下进行线程中断，我们是可以很方便的在线程中通过isInterrupted()方法判断当前线程是否发起中断操作，并执行相应的逻辑操作，但阻塞状态下，我们无法对线程施加额外的操作，线程本身就处于
    挂起状态，因此当发起中断请求时，只能是虚拟机帮我们实现通过异常的方式来中断阻塞，唤醒线程，通过异常的形式来执行异常里的逻辑代码，就跟if(isInterrupted())的逻辑一样。

    总结
    这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。


    进入运行状态的线程
    run()方法或main()方法结束后，线程就进入终止状态；

    当线程调用了自身的sleep()方法或其他线程的join()方法，进程让出CPU，然后就会进入阻塞状态（该状态既停止当前线程，但并不释放所占有的资源即调用sleep ()函数后，线程不会释放它的“锁标志”。）。当sleep()
    结束或join()结束后，该线程进入可运行状态，继续等待OS分配CPU时间片。典型地，sleep()被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。

    线程调用了yield()方法，意思是放弃当前获得的CPU时间片，回到就绪状态，这时与其他进程处于同等竞争状态，OS有可能会接着又让这个进程进入运行状态； 调用 yield() 的效果等价于调度程序认为该线程已执行了足
    够的时间片从而需要转到另一个线程。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。

    当线程刚进入可运行状态（注意，还没运行），发现将要调用的资源被synchronized（同步），获取不到锁标记，将会立即进入锁池状态，等待获取锁标记（这时的锁池里也许已经有了其他线程在等待获取锁标记，这时它们
    处于队列状态，既先到先得），一旦线程获得锁标记后，就转入就绪状态，等待OS分配CPU时间片；

    suspend() 和 resume()方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。典型地，suspend()和 resume() 被
    用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume()使其恢复。

    wait()和 notify() 方法：当线程调用wait()方法后会进入等待队列（进入这个状态会释放所占有的所有资源，与阻塞状态不同），进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()
    方法才能被唤醒（由于notify()只是唤醒一个线程，但我们由不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒，因此在实际使用时，一般都用notifyAll()方法，唤醒有所线程），线程被唤醒后会进
    入锁池，等待获取锁标记。

    wait() 使得线程进入阻塞状态，它有两种形式：
    一种允许指定以毫秒为单位的一段时间作为参数；另一种没有参数。前者当对应的 notify()被调用或者超出指定时间时线程重新进入可执行状态即就绪状态，后者则必须对应的 notify()被调用。当调用wait()后，线程会
    释放掉它所占有的“锁标志”，从而使线程所在对象中的其它synchronized数据可被别的线程使用。waite()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronizedblock中
    进行调用。如果在non-synchronized函数或non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。

    注意区别：初看起来wait() 和 notify() 方法与suspend()和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的suspend()及其它所有方法在线程阻塞时都不会释放占用的
    锁（如果占用了的话），而wait() 和 notify() 这一对方法则相反。

    上述的核心区别导致了一系列的细节上的区别
    首先，前面叙述的所有方法都隶属于 Thread类，但是wait() 和 notify() 方法这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一
    对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用任意对象的notify()方法则导致因调用该对象的 wait()方法而阻塞的线程中随机选
    择的一个解除阻塞（但要等到获得锁后才真正可执行）。

    其次，前面叙述的所有方法都可在任何位置调用，但是wait() 和 notify() 方法这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized方法或块中当前线程才占有锁，才有锁可以释
    放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足
    这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException异常。

    wait() 和 notify()方法的上述特性决定了它们经常和synchronized方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，
    它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block和wake up 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并
    用于解决各种复杂的线程间通信问题。

    关于 wait() 和 notify() 方法最后再说明两点：
    第一：调用notify() 方法导致解除阻塞的线程是从因调用该对象的 wait()方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。
    第二：除了notify()，还有一个方法 notifyAll()也可起到类似作用，唯一的区别在于，调用 notifyAll()方法将把因调用该对象的 wait()方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才
    能进入可执行状态。
    谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend()方法和不指定超时期限的wait()方法的调用都可能产生死锁。遗憾的是，Java并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。



















