//ReentrantLock公平锁的原理
//加锁逻辑
lock.lock()//加锁
sync.lock()//同步静态类实现
acquire(1)//state状态加1 FairSync公平锁

//加锁
public final void acquire(int arg) {
    //尝试获取锁
    if (!tryAcquire(arg) &&
        //获取锁失败后 构建当前线程的Note节点，加入同步队列中并挂起当前线程
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

//尝试获取锁
protected final boolean tryAcquire(int acquires) {
    //获取当前线程
    final Thread current = Thread.currentThread();
    //获取锁的标志状态
    int c = getState();
    //如果当前状态为0表示没有线程占有锁
    if (c == 0) {
        //公平锁逻辑，查询同步队列中是否存在其他等待获取锁的线程
        //如果当前同步队列中存在等待获取锁的线程，那么返回true，否则是false
        //首次进入时，head=tail，同步队列尚未初始化，此时一定没有，所以线程可以获得锁
        //其他线程进入时，如果不是之前被阻塞的线程唤醒后再次进入时，头节点一定不是尾节点，且头节点的下一个节点既不为空也不是当前线程
        //所以此时一定是true，所以尝试获取锁一定会失败，之后就会将当前线程挂起
        //如果是被挂起的线程被唤醒后再次尝试获取锁时，首先头节点一定不是尾节点，且头节点的下一个节点一定不为空，且是当前线程，所以此时返回的是false
        //那么这个时候就会获得锁，并占有锁，从公平的角度来说，也是这个逻辑，当前一个节点释放锁之后，一定是唤醒同步队列中head节点的下一个节点
        if (!hasQueuedPredecessors() &&
            //如果同步队列中没有其他等待获取锁的线程，那么直接将当前线程设置为锁独占
            //如果同步队列中有其他等待获取锁的线程，那么直接获取锁失败，返回false
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            //尝试获取锁成功
            return true;
        }
    }
    //否则就是已有线程占有锁，那么需要判断是否是同一线程占有锁，是的话就是可重入锁，状态+1
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        //尝试获取锁成功
        return true;
    }
    //尝试获取锁失败
    return false;
}

//判断当前同步队列中是否存在其他等待获取锁的线程，如果存在则返回true否则返回false
public final boolean hasQueuedPredecessors() {
    Node t = tail; // 尾节点
    Node h = head; // 头节点
    Node s; // 头节点的下一个节点
    //如果当前头节点不等于尾节点 如果头节点的下一个节点不为空或者下一个节点不是当前节点 这种情况只出现在被挂起的线程又再次被唤醒后
    //这里是第一次进入逻辑判断，那么头节点一定等于尾节点 因为同步队列还没有其他等待线程
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}

//构建当前线程的note节点，锁独占
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    Node pred = tail;
    //整个if的逻辑就是将当前note节点加入到队尾
    if (pred != null) {//如果同步队列已存在
        node.prev = pred;//将当前note节点的前一个节点置为tail节点
        if (compareAndSetTail(pred, node)) {//将当前note节点设置为tail节点
            pred.next = node;//将原tail节点的下一个节点设置为note节点
            return node;
        }
    }
    //首次尝试获取锁失败，初始化AQS同步队列
    enq(node);
    return node;
}

//首次初始化AQS同步队列
private Node enq(final Node node) {
    //自旋的方式
    for (;;) {
        Node t = tail;//尾节点
        if (t == null) { // 为节点不存在，即同步队列未初始化，此时需要初始化同步队列
            if (compareAndSetHead(new Node()))//初始化AQS同步队列，构建head节点
                tail = head;//初始化的同步队列，head节点也是tail节点，也即头节点也是尾节点，然后进入下一次循环
        } else {
            //这里的逻辑就是将新构建的note节点加入到队尾
            node.prev = t;//note节点的前一个节点设置为tail节点
            if (compareAndSetTail(t, node)) {//将note节点设置为tail节点
                t.next = node;//将原tail节点的下一个节点设置为note节点
                return t;
            }
        }
    }
}

final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        //自旋方式
        for (;;) {
            //当前note节点的前一个节点
            //如果是首次获取锁失败，则当前节点的前一个节点为head节点，否则进入下一个if将会挂起当前线程
            //另外还有一种就是被挂起的线程再次唤醒时，因为唤醒的总是head节点的下一个节点
            //如果当前节点的前一个节点是head节点，也就是当前要获的锁的线程就是最早加入等同步列的
            final Node p = node.predecessor();
            //再次尝试获取锁
            if (p == head && tryAcquire(arg)) {
                //如果获取锁成功，那么将当前节点设置为head节点，同时移除原head节点
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //当前节点的前一个节点不是head节点，也就是同步队列还有其他等待线程或者是尝试获取锁失败后
            //这个时候就要将当前note节点的前一个节点的waitStatus设置为-1，且挂起当前note节点的线程
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

//释放锁逻辑